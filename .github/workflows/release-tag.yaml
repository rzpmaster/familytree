name: Release on tag

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      action:
        description: "What to do: prerelease or promote"
        required: true
        type: choice
        options:
          - prerelease
          - promote
      version:
        description: "Base version tag (e.g. v1.2.3) for prerelease; or RC tag (e.g. v1.2.3-rc) for promote"
        required: true
      target:
        description: "Target ref/commit (optional). For prerelease: build this ref; for promote: build this ref (default: version)"
        required: false
        default: ""

permissions:
  contents: write
  packages: write

concurrency:
  group: release
  cancel-in-progress: false

jobs:
  # =========================
  # Decide tags/ref for both triggers
  # =========================
  meta:
    runs-on: ubuntu-latest
    outputs:
      mode: ${{ steps.meta.outputs.mode }}
      base_tag: ${{ steps.meta.outputs.base_tag }}
      rc_tag: ${{ steps.meta.outputs.rc_tag }}
      stable_tag: ${{ steps.meta.outputs.stable_tag }}
      build_ref: ${{ steps.meta.outputs.build_ref }}

    steps:
      - id: meta
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Determine mode and input
          if [[ "${{ github.event_name }}" == "push" ]]; then
            mode="prerelease"
            input_version="${GITHUB_REF_NAME}"
            input_target=""
          else
            mode="${{ inputs.action }}"
            input_version="${{ inputs.version }}"
            input_target="${{ inputs.target }}"
          fi

          # Determine build ref
          if [[ -z "$input_target" ]]; then
            build_ref="$input_version"
          else
            build_ref="$input_target"
          fi

          # Check if tag exists in remote
          tag_exists() {
            local tag="$1"
            git ls-remote --tags \
              "https://x-access-token:${GH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git" \
              "refs/tags/${tag}" | grep -q .
          }

          # RC always starts from rc.1
          next_rc_tag() {
            local base="$1"
            local i=1
            while true; do
              local candidate="${base}-rc.${i}"
              if ! tag_exists "$candidate"; then
                echo "$candidate"
                return 0
              fi
              i=$((i+1))
              if [[ $i -gt 9999 ]]; then
                echo "ERROR: too many rc tags for ${base}" >&2
                exit 1
              fi
            done
          }

          if [[ "$mode" == "prerelease" ]]; then
            base="$input_version"
            # Strip rc if user mistakenly passed one
            if [[ "$base" == *"-rc"* ]]; then
              base="${base%%-rc*}"
            fi

            rc="$(next_rc_tag "$base")"
            stable="$base"
          else
            # promote mode
            rc="$input_version"
            stable="${rc%%-rc*}"
            base="$stable"
          fi

          echo "mode=$mode" >> $GITHUB_OUTPUT
          echo "base_tag=$base" >> $GITHUB_OUTPUT
          echo "rc_tag=$rc" >> $GITHUB_OUTPUT
          echo "stable_tag=$stable" >> $GITHUB_OUTPUT
          echo "build_ref=$build_ref" >> $GITHUB_OUTPUT

  # =========================
  # Build artifacts (only for prerelease)
  # =========================
  build:
    needs: meta
    if: ${{ needs.meta.outputs.mode == 'prerelease' }}
    runs-on: ubuntu-latest
    outputs:
      rc_tag: ${{ needs.meta.outputs.rc_tag }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.meta.outputs.build_ref }}
          fetch-depth: 0

      # Frontend build
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: npm
          cache-dependency-path: frontend/package-lock.json

      - name: Install frontend and build
        working-directory: frontend
        run: |
          npm ci
          npm run build

      # Pack artifacts for release
      - name: Pack release artifacts
        run: |
          mkdir -p artifacts
          tar -czf artifacts/frontend-dist.tar.gz -C frontend dist

          # pack backend source too (exclude venv/cache)
          tar -czf artifacts/backend-src.tar.gz \
            --exclude=backend/.venv \
            --exclude=backend/__pycache__ \
            --exclude=backend/.ruff_cache \
            --exclude=backend/.pytest_cache \
            --exclude=backend/.mypy_cache \
            -C . backend

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: artifacts/*

  # =========================
  # Create pre-release (tag push OR manual prerelease)
  # =========================
  release:
    needs: [meta, build]
    if: ${{ needs.meta.outputs.mode == 'prerelease' }}
    runs-on: ubuntu-latest

    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: artifacts

      - name: Create GitHub Pre-release and upload assets
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.meta.outputs.rc_tag }}
          target_commitish: ${{ needs.meta.outputs.build_ref }}
          prerelease: true
          generate_release_notes: true
          files: |
            artifacts/frontend-dist.tar.gz
            artifacts/backend-src.tar.gz

  # =========================
  # Docker for prerelease: only push rc tag (no latest)
  # =========================
  docker:
    needs: [meta, build]
    if: ${{ needs.meta.outputs.mode == 'prerelease' }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.meta.outputs.build_ref }}

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker meta (backend)
        id: meta_backend
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}/backend
          tags: |
            type=raw,value=${{ needs.meta.outputs.rc_tag }}

      - name: Docker meta (frontend)
        id: meta_frontend
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}/frontend
          tags: |
            type=raw,value=${{ needs.meta.outputs.rc_tag }}

      - name: Build & push backend
        uses: docker/build-push-action@v6
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: ${{ steps.meta_backend.outputs.tags }}
          labels: ${{ steps.meta_backend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build & push frontend
        uses: docker/build-push-action@v6
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: ${{ steps.meta_frontend.outputs.tags }}
          labels: ${{ steps.meta_frontend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # =========================
  # Manual promote: unset prerelease
  # =========================
  promote_release:
    needs: meta
    if: ${{ needs.meta.outputs.mode == 'promote' }}
    runs-on: ubuntu-latest

    steps:
      - name: Create stable tag if not exists
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          stable="${{ needs.meta.outputs.stable_tag }}"
          rc="${{ needs.meta.outputs.rc_tag }}"

          git fetch --tags

          if git rev-parse "$stable" >/dev/null 2>&1; then
            echo "Stable tag $stable already exists, skip."
            exit 0
          fi

          echo "Creating stable tag $stable from $rc"
          git tag "$stable" "$rc"
          git push "https://x-access-token:${GH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git" "$stable"

      - name: Promote GitHub Release (prerelease -> false)
        uses: actions/github-script@v7
        with:
          script: |
            const rcTag = `${{ needs.meta.outputs.rc_tag }}`;

            const rel = await github.rest.repos.getReleaseByTag({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag: rcTag
            });

            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: rel.data.id,
              prerelease: false,
              draft: false
            });

            core.info(`Promoted ${rcTag} to stable release.`);

  # =========================
  # Manual promote: push stable docker tags + latest
  # =========================
  promote_docker:
    needs: meta
    if: ${{ needs.meta.outputs.mode == 'promote' }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.meta.outputs.build_ref }}
          fetch-depth: 0

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker meta (backend)
        id: meta_backend
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}/backend
          tags: |
            type=raw,value=latest
            type=raw,value=${{ needs.meta.outputs.stable_tag }}

      - name: Docker meta (frontend)
        id: meta_frontend
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}/frontend
          tags: |
            type=raw,value=latest
            type=raw,value=${{ needs.meta.outputs.stable_tag }}

      - name: Build & push backend (stable)
        uses: docker/build-push-action@v6
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: ${{ steps.meta_backend.outputs.tags }}
          labels: ${{ steps.meta_backend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build & push frontend (stable)
        uses: docker/build-push-action@v6
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: ${{ steps.meta_frontend.outputs.tags }}
          labels: ${{ steps.meta_frontend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # =========================
  # clear image
  # =========================
  cleanup_rc_images:
    needs: [meta, promote_release, promote_docker]
    if: ${{ needs.meta.outputs.mode == 'promote' }}
    runs-on: ubuntu-latest

    steps:
      - name: Delete RC container image versions (backend/frontend)
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const rcTag = `${{ needs.meta.outputs.rc_tag }}`;
            const packages = ['backend', 'frontend'];

            async function listVersions(pkg) {
              // Try user-owned package first, then org-owned.
              try {
                return await github.rest.packages.getAllPackageVersionsForPackageOwnedByUser({
                  package_type: "container",
                  package_name: `${repo}/${pkg}`,
                  username: owner,
                  per_page: 100,
                });
              } catch (e1) {
                return await github.rest.packages.getAllPackageVersionsForPackageOwnedByOrg({
                  package_type: "container",
                  package_name: `${repo}/${pkg}`,
                  org: owner,
                  per_page: 100,
                });
              }
            }

            async function deleteVersion(pkg, id) {
              // Try user-owned delete first, then org-owned.
              try {
                await github.rest.packages.deletePackageVersionForUser({
                  package_type: "container",
                  package_name: `${repo}/${pkg}`,
                  username: owner,
                  package_version_id: id,
                });
              } catch (e1) {
                await github.rest.packages.deletePackageVersionForOrg({
                  package_type: "container",
                  package_name: `${repo}/${pkg}`,
                  org: owner,
                  package_version_id: id,
                });
              }
            }

            for (const pkg of packages) {
              core.info(`Scanning package: ${repo}/${pkg} for rc tag: ${rcTag}`);
              const res = await listVersions(pkg);
              const versions = res.data || [];

              // Each version may have metadata.container.tags
              const targets = versions.filter(v => {
                const tags = v.metadata?.container?.tags || [];
                return tags.includes(rcTag);
              });

              if (targets.length === 0) {
                core.info(`No versions found with tag ${rcTag} for ${repo}/${pkg}`);
                continue;
              }

              for (const v of targets) {
                core.info(`Deleting ${repo}/${pkg} version_id=${v.id} tags=${(v.metadata?.container?.tags||[]).join(',')}`);
                await deleteVersion(pkg, v.id);
              }
            }

            core.info(`Cleanup done for rc tag: ${rcTag}`);
